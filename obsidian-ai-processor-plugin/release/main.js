/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AIProcessorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  geminiApiKey: "",
  gemini25FlashApiKey: "",
  gemini25ProApiKey: "",
  claudeApiKey: "",
  perplexityApiKey: "",
  defaultModel: "gemini",
  defaultPrompt: "Process the following content:"
};
var AIProcessorPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("brain", "AI Processor", () => {
      new ProcessorModal(this.app, this).open();
    });
    this.addCommand({
      id: "open-ai-processor",
      name: "Open AI Processor",
      callback: () => {
        new ProcessorModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "process-current-file",
      name: "Process current file with AI",
      callback: () => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.extension === "md") {
          new QuickProcessModal(this.app, this, file).open();
        } else {
          new import_obsidian.Notice("No markdown file is currently open");
        }
      }
    });
    this.addCommand({
      id: "extract-file-names",
      name: "Extract file names from folder",
      callback: () => {
        new ExtractNamesModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "clear-markdown-content",
      name: "Clear markdown content",
      callback: () => {
        new ClearMarkdownModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "remove-id-lines",
      name: "Remove ID lines from markdown",
      callback: () => {
        new RemoveIDLinesModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "create-md-from-txt-names",
      name: "Create MD files from TXT names",
      callback: () => {
        new CreateMDFromTXTModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "copy-directory-structure",
      name: "Copy directory structure",
      callback: () => {
        new CopyDirStructureModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "vocabulary-to-table",
      name: "Convert vocabulary to Obsidian table",
      callback: () => {
        new VocabToTableModal(this.app, this).open();
      }
    });
    this.addSettingTab(new AIProcessorSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // ==================== AI API METHODS ====================
  async processWithAI(content, prompt, model) {
    switch (model) {
      case "gemini":
        return await this.processWithGemini(content, prompt);
      case "gemini-2.5-flash":
        return await this.processWithGemini25Flash(content, prompt);
      case "gemini-2.5-pro":
        return await this.processWithGemini25Pro(content, prompt);
      case "claude":
        return await this.processWithClaude(content, prompt);
      case "perplexity":
        return await this.processWithPerplexity(content, prompt);
      default:
        throw new Error("Unknown model: " + model);
    }
  }
  async processWithFilename(filename, prompt, model) {
    const content = `T\xEAn file: ${filename}`;
    return await this.processWithAI(content, prompt, model);
  }
  async processWithGemini(content, prompt) {
    var _a, _b, _c, _d, _e;
    if (!this.settings.geminiApiKey) {
      throw new Error("Gemini API key not configured");
    }
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${this.settings.geminiApiKey}`;
    const response = await (0, import_obsidian.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `${prompt}

${content}`
          }]
        }]
      })
    });
    if (response.status === 200) {
      const result = response.json;
      return ((_e = (_d = (_c = (_b = (_a = result.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) || "";
    } else {
      throw new Error(`Gemini API error: ${response.text}`);
    }
  }
  async processWithGemini25Flash(content, prompt) {
    var _a, _b, _c, _d, _e;
    if (!this.settings.gemini25FlashApiKey) {
      throw new Error("Gemini 2.5 Flash API key not configured");
    }
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${this.settings.gemini25FlashApiKey}`;
    const response = await (0, import_obsidian.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `${prompt}

${content}`
          }]
        }]
      })
    });
    if (response.status === 200) {
      const result = response.json;
      return ((_e = (_d = (_c = (_b = (_a = result.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) || "";
    } else {
      throw new Error(`Gemini 2.5 Flash API error: ${response.text}`);
    }
  }
  async processWithGemini25Pro(content, prompt) {
    var _a, _b, _c, _d, _e;
    if (!this.settings.gemini25ProApiKey) {
      throw new Error("Gemini 2.5 Pro API key not configured");
    }
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${this.settings.gemini25ProApiKey}`;
    const response = await (0, import_obsidian.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `${prompt}

${content}`
          }]
        }]
      })
    });
    if (response.status === 200) {
      const result = response.json;
      return ((_e = (_d = (_c = (_b = (_a = result.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) || "";
    } else {
      throw new Error(`Gemini 2.5 Pro API error: ${response.text}`);
    }
  }
  async processWithClaude(content, prompt) {
    var _a, _b;
    if (!this.settings.claudeApiKey) {
      throw new Error("Claude API key not configured");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.settings.claudeApiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: "claude-sonnet-4-20250514",
        max_tokens: 2e4,
        temperature: 1,
        messages: [{
          role: "user",
          content: `${prompt}

${content}`
        }]
      })
    });
    if (response.status === 200) {
      const result = response.json;
      return ((_b = (_a = result.content) == null ? void 0 : _a[0]) == null ? void 0 : _b.text) || "";
    } else {
      throw new Error(`Claude API error: ${response.text}`);
    }
  }
  async processWithPerplexity(content, prompt) {
    var _a, _b, _c;
    if (!this.settings.perplexityApiKey) {
      throw new Error("Perplexity API key not configured");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.perplexity.ai/chat/completions",
      method: "POST",
      headers: {
        "accept": "application/json",
        "content-type": "application/json",
        "Authorization": `Bearer ${this.settings.perplexityApiKey}`
      },
      body: JSON.stringify({
        model: "sonar-pro",
        messages: [
          {
            role: "system",
            content: "B\u1EA1n l\xE0 m\u1ED9t chuy\xEAn gia ng\xF4n ng\u1EEF h\u1ECDc v\u1EDBi kinh nghi\u1EC7m x\xE2y d\u1EF1ng h\u1EC7 th\u1ED1ng t\u1EEB v\u1EF1ng v\xE0 ph\u01B0\u01A1ng ph\xE1p ghi nh\u1EDB hi\u1EC7u qu\u1EA3."
          },
          {
            role: "user",
            content: `${prompt}

${content}`
          }
        ]
      })
    });
    if (response.status === 200) {
      const result = response.json;
      return ((_c = (_b = (_a = result.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || "";
    } else {
      throw new Error(`Perplexity API error: ${response.text}`);
    }
  }
};
var AIProcessorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\u{1F916} AI Processor Settings" });
    containerEl.createEl("h3", { text: "\u{1F511} API Keys" });
    new import_obsidian.Setting(containerEl).setName("Gemini API Key").setDesc("Enter your Google Gemini API key").addText((text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
      this.plugin.settings.geminiApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Gemini 2.5 Flash API Key").setDesc("Enter your Google Gemini 2.5 Flash API key").addText((text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.gemini25FlashApiKey).onChange(async (value) => {
      this.plugin.settings.gemini25FlashApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Gemini 2.5 Pro API Key").setDesc("Enter your Google Gemini 2.5 Pro API key").addText((text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.gemini25ProApiKey).onChange(async (value) => {
      this.plugin.settings.gemini25ProApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Claude API Key").setDesc("Enter your Anthropic Claude API key").addText((text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.claudeApiKey).onChange(async (value) => {
      this.plugin.settings.claudeApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Perplexity API Key").setDesc("Enter your Perplexity API key").addText((text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.perplexityApiKey).onChange(async (value) => {
      this.plugin.settings.perplexityApiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "\u2699\uFE0F Default Settings" });
    new import_obsidian.Setting(containerEl).setName("Default AI Model").setDesc("Choose the default AI model for processing").addDropdown((dropdown) => dropdown.addOption("gemini", "Gemini 2.0 Flash").addOption("gemini-2.5-flash", "Gemini 2.5 Flash").addOption("gemini-2.5-pro", "Gemini 2.5 Pro").addOption("claude", "Claude Sonnet 4").addOption("perplexity", "Perplexity Sonar Pro").setValue(this.plugin.settings.defaultModel).onChange(async (value) => {
      this.plugin.settings.defaultModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Prompt").setDesc("Set a default prompt for AI processing").addTextArea((text) => text.setPlaceholder("Enter default prompt").setValue(this.plugin.settings.defaultPrompt).onChange(async (value) => {
      this.plugin.settings.defaultPrompt = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "\u{1F4D6} Help" });
    const helpDiv = containerEl.createDiv("ai-processor-help");
    helpDiv.innerHTML = `
			<p><strong>How to use:</strong></p>
			<ul>
				<li>Click the brain icon in the left ribbon to open the AI Processor</li>
				<li>Use commands from the command palette (Ctrl/Cmd + P)</li>
				<li>Configure your API keys above to start processing</li>
			</ul>
			<p><strong>Available Models:</strong></p>
			<ul>
				<li><strong>Gemini 2.0 Flash:</strong> Fast and efficient for general tasks</li>
				<li><strong>Gemini 2.5 Flash:</strong> Latest Gemini with improved performance</li>
				<li><strong>Gemini 2.5 Pro:</strong> Most capable Gemini model</li>
				<li><strong>Claude Sonnet 4:</strong> Excellent for complex reasoning</li>
				<li><strong>Perplexity Sonar Pro:</strong> Great for research and factual content</li>
			</ul>
		`;
  }
};
var ProcessorModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.selectedMode = "convert-md";
    this.selectedFiles = [];
    this.currentFolder = null;
    this.plugin = plugin;
    this.selectedModel = plugin.settings.defaultModel;
    this.prompt = plugin.settings.defaultPrompt;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("ai-processor-modal");
    contentEl.createEl("h2", { text: "\u{1F916} AI Processor" });
    const modeSection = contentEl.createDiv("processor-section");
    modeSection.createEl("h3", { text: "\u{1F4CB} Processing Mode" });
    const modeGrid = modeSection.createDiv("mode-grid");
    const modes = [
      { id: "convert-md", icon: "\u{1F504}", name: "Process Markdown", desc: "Process MD files with AI" },
      { id: "convert-txt", icon: "\u{1F4DD}", name: "Process TXT to MD", desc: "Convert TXT to Markdown" },
      { id: "append-ai", icon: "\u2795", name: "Append AI Content", desc: "Add AI content to MD" },
      { id: "md-filename", icon: "\u{1F3F7}\uFE0F", name: "Process by Filename", desc: "Use filename as context" },
      { id: "extract-names", icon: "\u{1F4CB}", name: "Extract Names", desc: "Extract file names to TXT" },
      { id: "clear-md", icon: "\u{1F9F9}", name: "Clear Markdown", desc: "Clear MD content" },
      { id: "remove-id", icon: "\u{1F5D1}\uFE0F", name: "Remove ID Lines", desc: "Remove ID comments" },
      { id: "classify", icon: "\u{1F4C1}", name: "Classify Files", desc: "Sort files by content" },
      { id: "vocab-table", icon: "\u{1F4DA}", name: "Vocab to Table", desc: "Convert to Obsidian table" }
    ];
    modes.forEach((mode) => {
      const modeCard = modeGrid.createDiv("mode-card");
      if (mode.id === this.selectedMode) {
        modeCard.addClass("selected");
      }
      modeCard.innerHTML = `
				<div class="mode-icon">${mode.icon}</div>
				<div class="mode-name">${mode.name}</div>
				<div class="mode-desc">${mode.desc}</div>
			`;
      modeCard.addEventListener("click", () => {
        modeGrid.querySelectorAll(".mode-card").forEach((c) => c.removeClass("selected"));
        modeCard.addClass("selected");
        this.selectedMode = mode.id;
        this.updateUIForMode();
      });
    });
    const fileSection = contentEl.createDiv("processor-section");
    fileSection.createEl("h3", { text: "\u{1F4C2} Select Files" });
    const folderSelector = fileSection.createDiv("folder-selector");
    const folderInput = folderSelector.createEl("input", {
      type: "text",
      placeholder: "Select a folder...",
      attr: { readonly: "true" }
    });
    const selectFolderBtn = folderSelector.createEl("button", { text: "\u{1F4C1} Browse" });
    selectFolderBtn.addEventListener("click", () => {
      new FolderSelectorModal(this.app, (folder) => {
        this.currentFolder = folder;
        folderInput.value = folder.path;
        this.loadFilesFromFolder(folder, fileListDiv);
      }).open();
    });
    const fileListDiv = fileSection.createDiv("file-list");
    const aiSection = contentEl.createDiv("processor-section");
    aiSection.createEl("h3", { text: "\u{1F916} AI Settings" });
    const modelSelect = aiSection.createEl("select", { cls: "ai-model-select" });
    const models = [
      { value: "gemini", label: "Gemini 2.0 Flash" },
      { value: "gemini-2.5-flash", label: "Gemini 2.5 Flash" },
      { value: "gemini-2.5-pro", label: "Gemini 2.5 Pro" },
      { value: "claude", label: "Claude Sonnet 4" },
      { value: "perplexity", label: "Perplexity Sonar Pro" }
    ];
    models.forEach((m) => {
      const option = modelSelect.createEl("option", {
        value: m.value,
        text: m.label
      });
      if (m.value === this.selectedModel) {
        option.selected = true;
      }
    });
    modelSelect.addEventListener("change", () => {
      this.selectedModel = modelSelect.value;
    });
    const promptLabel = aiSection.createEl("label", { text: "Prompt:" });
    const promptArea = aiSection.createEl("textarea", {
      cls: "ai-prompt-area",
      placeholder: "Enter your prompt here..."
    });
    promptArea.value = this.prompt;
    promptArea.addEventListener("input", () => {
      this.prompt = promptArea.value;
    });
    const actionSection = contentEl.createDiv("processor-section action-section");
    const processBtn = actionSection.createEl("button", {
      cls: "mod-cta process-btn",
      text: "\u25B6\uFE0F Process Files"
    });
    processBtn.addEventListener("click", async () => {
      await this.processFiles();
    });
    const cancelBtn = actionSection.createEl("button", {
      text: "\u274C Cancel"
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    this.updateUIForMode();
  }
  updateUIForMode() {
  }
  loadFilesFromFolder(folder, container) {
    container.empty();
    const files = folder.children.filter((f) => f instanceof import_obsidian.TFile);
    if (files.length === 0) {
      container.createEl("p", { text: "No files in this folder", cls: "no-files" });
      return;
    }
    const selectAllDiv = container.createDiv("select-all-div");
    const selectAllCheckbox = selectAllDiv.createEl("input", { type: "checkbox" });
    selectAllDiv.createEl("label", { text: "Select All" });
    selectAllCheckbox.addEventListener("change", () => {
      const checkboxes = container.querySelectorAll('.file-item input[type="checkbox"]');
      checkboxes.forEach((cb) => {
        cb.checked = selectAllCheckbox.checked;
      });
      this.updateSelectedFiles(files, selectAllCheckbox.checked);
    });
    files.forEach((file) => {
      const fileItem = container.createDiv("file-item");
      const checkbox = fileItem.createEl("input", { type: "checkbox" });
      fileItem.createEl("label", { text: file.name });
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedFiles.push(file);
        } else {
          this.selectedFiles = this.selectedFiles.filter((f) => f !== file);
        }
      });
    });
  }
  updateSelectedFiles(files, selected) {
    if (selected) {
      this.selectedFiles = [...files];
    } else {
      this.selectedFiles = [];
    }
  }
  async processFiles() {
    var _a;
    if (this.selectedFiles.length === 0) {
      new import_obsidian.Notice("Please select at least one file");
      return;
    }
    if (!this.prompt.trim()) {
      new import_obsidian.Notice("Please enter a prompt");
      return;
    }
    new import_obsidian.Notice(`Processing ${this.selectedFiles.length} files...`);
    try {
      let processedCount = 0;
      for (const file of this.selectedFiles) {
        const content = await this.app.vault.read(file);
        let processedContent;
        if (this.selectedMode === "md-filename") {
          processedContent = await this.plugin.processWithFilename(
            file.basename,
            this.prompt,
            this.selectedModel
          );
          await this.app.vault.modify(file, processedContent);
        } else if (this.selectedMode === "append-ai") {
          processedContent = await this.plugin.processWithAI(
            content,
            this.prompt,
            this.selectedModel
          );
          await this.app.vault.modify(file, content + "\n\n" + processedContent);
        } else {
          processedContent = await this.plugin.processWithAI(
            content,
            this.prompt,
            this.selectedModel
          );
          const newFileName = file.basename + "_processed.md";
          const newPath = (0, import_obsidian.normalizePath)(((_a = file.parent) == null ? void 0 : _a.path) + "/" + newFileName);
          await this.app.vault.create(newPath, processedContent);
        }
        processedCount++;
        new import_obsidian.Notice(`Processed ${processedCount}/${this.selectedFiles.length} files`);
      }
      new import_obsidian.Notice(`\u2705 Successfully processed ${processedCount} files!`);
      this.close();
    } catch (error) {
      new import_obsidian.Notice(`\u274C Error: ${error.message}`);
      console.error("Processing error:", error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var QuickProcessModal = class extends import_obsidian.Modal {
  constructor(app, plugin, file) {
    super(app);
    this.plugin = plugin;
    this.file = file;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("quick-process-modal");
    contentEl.createEl("h2", { text: `\u{1F680} Quick Process: ${this.file.name}` });
    const promptArea = contentEl.createEl("textarea", {
      cls: "quick-prompt-area",
      placeholder: "Enter prompt..."
    });
    promptArea.value = this.plugin.settings.defaultPrompt;
    const modelSelect = contentEl.createEl("select", { cls: "quick-model-select" });
    const models = [
      { value: "gemini", label: "Gemini 2.0 Flash" },
      { value: "gemini-2.5-flash", label: "Gemini 2.5 Flash" },
      { value: "gemini-2.5-pro", label: "Gemini 2.5 Pro" },
      { value: "claude", label: "Claude Sonnet 4" },
      { value: "perplexity", label: "Perplexity Sonar Pro" }
    ];
    models.forEach((m) => {
      const option = modelSelect.createEl("option", { value: m.value, text: m.label });
      if (m.value === this.plugin.settings.defaultModel) {
        option.selected = true;
      }
    });
    const btnContainer = contentEl.createDiv("btn-container");
    const processBtn = btnContainer.createEl("button", {
      cls: "mod-cta",
      text: "\u25B6\uFE0F Process"
    });
    processBtn.addEventListener("click", async () => {
      var _a;
      const content = await this.app.vault.read(this.file);
      const prompt = promptArea.value;
      const model = modelSelect.value;
      try {
        new import_obsidian.Notice("Processing...");
        const result = await this.plugin.processWithAI(content, prompt, model);
        const newFileName = this.file.basename + "_processed.md";
        const newPath = (0, import_obsidian.normalizePath)(((_a = this.file.parent) == null ? void 0 : _a.path) + "/" + newFileName);
        await this.app.vault.create(newPath, result);
        new import_obsidian.Notice("\u2705 Processing complete!");
        this.close();
      } catch (error) {
        new import_obsidian.Notice(`\u274C Error: ${error.message}`);
      }
    });
    const cancelBtn = btnContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FolderSelectorModal = class extends import_obsidian.Modal {
  constructor(app, onSelectFolder) {
    super(app);
    this.onSelectFolder = onSelectFolder;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F4C1} Select Folder" });
    const folders = this.getAllFolders();
    folders.forEach((folder) => {
      const folderItem = contentEl.createDiv("folder-item");
      folderItem.textContent = folder.path || "/";
      folderItem.addEventListener("click", () => {
        this.onSelectFolder(folder);
        this.close();
      });
    });
  }
  getAllFolders() {
    const folders = [];
    const root = this.app.vault.getRoot();
    const traverse = (folder) => {
      folders.push(folder);
      folder.children.forEach((child) => {
        if (child instanceof import_obsidian.TFolder) {
          traverse(child);
        }
      });
    };
    traverse(root);
    return folders;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ExtractNamesModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F4CB} Extract File Names" });
    contentEl.createEl("p", { text: "Select a folder to extract file names from:" });
    const selectBtn = contentEl.createEl("button", {
      cls: "mod-cta",
      text: "\u{1F4C1} Select Folder"
    });
    selectBtn.addEventListener("click", () => {
      new FolderSelectorModal(this.app, async (folder) => {
        const files = folder.children.filter((f) => f instanceof import_obsidian.TFile);
        const fileNames = files.map((f) => f.basename).join("\n");
        const outputPath = (0, import_obsidian.normalizePath)(folder.path + "/extracted_names.txt");
        await this.app.vault.create(outputPath, fileNames);
        new import_obsidian.Notice(`\u2705 Extracted ${files.length} file names!`);
        this.close();
      }).open();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ClearMarkdownModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F9F9} Clear Markdown Content" });
    contentEl.createEl("p", {
      text: "\u26A0\uFE0F This will clear all content from markdown files in the selected folder!",
      cls: "warning-text"
    });
    const selectBtn = contentEl.createEl("button", {
      cls: "mod-warning",
      text: "\u{1F4C1} Select Folder"
    });
    selectBtn.addEventListener("click", () => {
      new FolderSelectorModal(this.app, async (folder) => {
        const files = folder.children.filter(
          (f) => f instanceof import_obsidian.TFile && f.extension === "md"
        );
        for (const file of files) {
          await this.app.vault.modify(file, "");
        }
        new import_obsidian.Notice(`\u2705 Cleared ${files.length} markdown files!`);
        this.close();
      }).open();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var RemoveIDLinesModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F5D1}\uFE0F Remove ID Lines" });
    contentEl.createEl("p", { text: "Remove <!--ID: ...--> lines from markdown files" });
    const selectBtn = contentEl.createEl("button", {
      cls: "mod-cta",
      text: "\u{1F4C1} Select Folder"
    });
    selectBtn.addEventListener("click", () => {
      new FolderSelectorModal(this.app, async (folder) => {
        const files = folder.children.filter(
          (f) => f instanceof import_obsidian.TFile && f.extension === "md"
        );
        let processedCount = 0;
        for (const file of files) {
          const content = await this.app.vault.read(file);
          const newContent = content.replace(/^<!--ID: .+-->\s*$/gm, "");
          if (content !== newContent) {
            await this.app.vault.modify(file, newContent);
            processedCount++;
          }
        }
        new import_obsidian.Notice(`\u2705 Removed ID lines from ${processedCount} files!`);
        this.close();
      }).open();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CreateMDFromTXTModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F4C4} Create MD from TXT Names" });
    contentEl.createEl("p", { text: "Create empty markdown files named after TXT files" });
    const selectBtn = contentEl.createEl("button", {
      cls: "mod-cta",
      text: "\u{1F4C1} Select Folder"
    });
    selectBtn.addEventListener("click", () => {
      new FolderSelectorModal(this.app, async (folder) => {
        const txtFiles = folder.children.filter(
          (f) => f instanceof import_obsidian.TFile && f.extension === "txt"
        );
        let createdCount = 0;
        for (const file of txtFiles) {
          const mdPath = (0, import_obsidian.normalizePath)(folder.path + "/" + file.basename + ".md");
          if (!await this.app.vault.adapter.exists(mdPath)) {
            await this.app.vault.create(mdPath, "");
            createdCount++;
          }
        }
        new import_obsidian.Notice(`\u2705 Created ${createdCount} markdown files!`);
        this.close();
      }).open();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CopyDirStructureModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F4C1} Copy Directory Structure" });
    contentEl.createEl("p", { text: "This feature requires manual folder selection" });
    contentEl.createEl("p", {
      text: "Use the file explorer to copy folder structures",
      cls: "muted"
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var VocabToTableModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u{1F4DA} Convert Vocabulary to Table" });
    contentEl.createEl("p", { text: "Select files containing vocabulary entries:" });
    const selectBtn = contentEl.createEl("button", {
      cls: "mod-cta",
      text: "\u{1F4C1} Select Folder"
    });
    selectBtn.addEventListener("click", () => {
      new FolderSelectorModal(this.app, async (folder) => {
        const files = folder.children.filter(
          (f) => f instanceof import_obsidian.TFile && f.extension === "md"
        );
        let allEntries = [];
        for (const file of files) {
          const content = await this.app.vault.read(file);
          const entries = this.parseVocabularyEntries(content);
          allEntries = allEntries.concat(entries);
        }
        const table = this.createObsidianTable(allEntries);
        const outputPath = (0, import_obsidian.normalizePath)(folder.path + "/vocabulary_table.md");
        const header = `# Vocabulary Table

**Files processed:** ${files.length}
**Total entries:** ${allEntries.length}

---

`;
        await this.app.vault.create(outputPath, header + table);
        new import_obsidian.Notice(`\u2705 Created vocabulary table with ${allEntries.length} entries!`);
        this.close();
      }).open();
    });
  }
  parseVocabularyEntries(text) {
    const entries = [];
    const parts = text.split(/\n(?=EN-Words)/);
    for (const part of parts) {
      if (!part.trim())
        continue;
      const entry = {};
      const vocabMatch = part.match(/Vocabulary:\s*(.+)/);
      if (vocabMatch)
        entry.vocabulary = vocabMatch[1].trim();
      const pronunciationMatch = part.match(/Pronunciation:\s*(.+)/);
      if (pronunciationMatch)
        entry.pronunciation = pronunciationMatch[1].trim();
      const definitionMatch = part.match(/Definition:\s*(.+)/);
      if (definitionMatch)
        entry.definition = definitionMatch[1].trim();
      const exampleMatch = part.match(/Example:\s*(.+)/);
      if (exampleMatch)
        entry.example = exampleMatch[1].trim();
      const audioMatch = part.match(/Audio:\s*(!?\[\[.+?\]\])/);
      if (audioMatch)
        entry.audio = audioMatch[1].trim();
      const posMatch = part.match(/Part of Speech:\s*(.+)/);
      if (posMatch)
        entry.partOfSpeech = posMatch[1].trim();
      if (entry.vocabulary) {
        entries.push(entry);
      }
    }
    return entries;
  }
  createObsidianTable(entries) {
    let table = "| Word | Part of Speech | Definition | Pronunciation | Audio | Example |\n";
    table += "|------|---------------|------------|---------------|-------|---------|\n";
    for (const entry of entries) {
      const vocab = (entry.vocabulary || "").replace(/\|/g, "\\|");
      let pos = entry.partOfSpeech || "";
      if (pos.toLowerCase().includes("adjective"))
        pos = "adj.";
      else if (pos.toLowerCase().includes("noun"))
        pos = "n.";
      else if (pos.toLowerCase().includes("verb"))
        pos = "v.";
      else if (pos.toLowerCase().includes("adverb"))
        pos = "adv.";
      else
        pos = pos.split(",")[0];
      let definition = (entry.definition || "").replace(/\|/g, "\\|");
      if (definition.length > 60)
        definition = definition.substring(0, 60) + "...";
      const pronunciation = (entry.pronunciation || "").replace(/\|/g, "\\|");
      const audio = (entry.audio || "").replace(/\|/g, "\\|");
      const example = (entry.example || "").replace(/\|/g, "\\|");
      table += `| ${vocab} | ${pos} | ${definition} | ${pronunciation} | ${audio} | ${example} |
`;
    }
    return table;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
